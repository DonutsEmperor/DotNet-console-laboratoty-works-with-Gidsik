# Laba6 - Многопоточное программирование, Синхронное и Асинхронное программирование 

> **ВАЖНО:**
> - **создаём для лабы ОДНО решение**
> - **в папке с решением инициализируем репозиторий**
> - **проекты решния должны находиться в ПОДПАПКАХ**
> - **каждая задача должна собой представлять или отдельный файл с классом в проекте, или отдельный проект**
> - **Юнит тесты - отдельные проекты**
> - **Грамотно оформляйте решение, разносите классы в отдельные файлы**
> - **не используйте кириллицу, русский язык, транслит и тп**  
>   **Пример:**
>   - **для массива не ``mas``, а ``arr``**
>   - **для количества не ``kol``, а ``count``**

## Задания:

### #0 Немного теории многотопоточного программирования

> ### Подробнее теорию и разбор вы можете изучить в документации к .NET ИЛИ на русском сайте с руководством и примерами [metanit.com](https://metanit.com/sharp/tutorial/11.1.php) Главы 14-16

### Основа многопоточного программирования  

Ею является такая сущность как "поток" или "нить" - "thread", это поток выполнения, некий контекст в котором последовательно выполняются операторы.  

В .NET функционал связанный с многопоточным программированием находится в неймспейсе ``System.Threading``  
Класс ``Thread`` — находится в этом неймспейсе, представляет собой один поток.  
> При инициализации нового объекта потока в констуктор необходимо передать метод, который будет в этом потоке выполняться.  
> Такую передачу можно осуществить с помощью прямой передачи метода, соответствующего делегату, в том числе с помощью лямба-выражения.  

У этого класса есть набор свойств и методов, перечислю основные:  
Свойства:
- ``IsAlive`` — буловое свойство. указывает, работает ли поток в текущий момент  
- ``Name`` — содержит имя потока  
- ``ThreadState`` — содержит текущее состояние потока, которое отражается в виде одного из значений перечисления ``ThreadState`` (у свойства и перечисления одинаковые имена)  
- ``CurrentThread`` —  статическое свойство класса, возвращет текущий поток (в котором произошло обращение к свойству)  

Методы:
- ``Sleep()`` — статический метод, принимает на вход число представляющиее собой милисекунлды, приостанавливает выполнение текущего потока на это кол-во милисекунд  
- ``Interrupt()`` — метод прерывающий работу потока, находящегося в состоянии ``ThreadState.WaitSleepJoin``
- ``Join()`` — метод который ставит на паузу текущий поток до тех пор, пока не завершится поток для которого был вызван этот метод  
- ``Start()`` — метод запускающий поток на выполнение  

Так же стоит упомянуть устаревшиеи методы, которые не рекомендуют к использованию в современном программировании, так как они могут приводить к так называемым deadlock'ам, полным зависаниям программы и непредопределенному поведению:

Устаревшие методы:
- ``Abort()`` — метод завершающий работу поток  
- ``Suspend()`` — метод приостанавливающий работу потока до тех пор пока её не возобновят  
- ``Resume()`` — метод возобновляющий работу потока  

Рекомендуется использовать другие классы и методы из пространства имён ``System.Threading`` для работы с синхронизацией потоков или защиты данных при работе с данными из нескольких потоков.  

### Инструменты для синхронизации потоков:
- класс ``Monitor`` и оператор ``lock`` — делают одно и то же, с их помощью можно отметить область кода, работа с которой должна выполняться единовременно только одним потоком.  
> ```c# 
>   object locker = new();  //пустой объект заглушка
>
>   lock (locker)
>   {
>       //Some synced logic
>   }
> ```
> ```c# 
>   object locker = new();  //пустой объект заглушка
>
>   Monitor.Enter(locker);
>   //Some synced logic
>   Monitor.Exit(locker);
> ```

- класс ``AutoResetEvent`` — служит для синхронизации потоков с помощью событий\сигналов. Объект этого класса может быть в сигнальном и несигнальном состоянии, ориентируясь на этот объект потоки синхронизируют работу.  
Содержит следующие методы:
    - ``Reset()`` — задаёт несигнальное состояние ивента  
    - ``Set()`` — задаёт сигнальное состояние ивента  
    - ``WaitOne()`` — задаёт несигнальное состояние ивента И блокирует текущий поток до тех пор, пока объект ивента не получит сигнальное состояние  

> ```c# 
>   AutoResetEvent waitHandler = new AutoResetEvent(true);  //объект события\ивента, изначально true (в сигнальном состоянии)
>
>   waitHandler.WaitOne(); //ждём сигнала из вне преджде чем выполнять лог
>   //Some synced logic
>   waitHandler.Set(); // устанавливаем waitHandler в сигнальное состояние
> ```


- класс ``Mutex`` — ещё один инструмент для синхронизаций потоков, потоки "захватывают" объекты мьютекса во владение и другие потоки не могут выполняться пока мьютекс не освободят  
Содержит следующие методы:
    - ``WaitOne()`` — приостанавливает поток до получения мьютекса  
    - ``ReleaseMutex()`` — освобождает мьютек  

> ```c# 
>   Mutex mutexObj = new Mutex();  //объект события\ивента, изначально true (в сигнальном состоянии)
>
>   mutexObj.WaitOne(); //приостанавливаем поток до получения мьютекса  
>   //Some synced logic
>   mutexObj.Set(); // освобождаем мьютекс
> ```


---


### #1 Написать Программу в которой будет два потока со своми задачами и общими ресурсами

Создайте новый консольный проект.  
В нём создайте класс ``ThreadWorker``, у которого должен быть метод ``Work`` который будет обрабатывать ввод с клавиатуры в бесконечном цикле, считывая строки с клавитуры.  
В зависимости от введённой строки должны выполняться разные задачи:  
- ``create`` — должна предложить пользователю ввести имя персоны и её возраст, добавить их в очередь в виде строк, после и сигнализировать фоновому потоку приниматься за работу  
- ``list`` — должна вывести список пользователей в консоль  
- ``exit`` — должна завершить работу программы  

Так же в этом классе нужно объявить приватное поле хранящее поток ``_backgroundThread``.  
В этом же классе нужно написать метод ``ThreadMethod`` в котором в бесконечном цикле будет ожидаться сигнал, при получении которого нужно считать из очереди строки и на их основе инициализировать новый объект типа ``Person`` и добавить его в список, после чего список нужно отсортировать по возрасту персон.  

Общие ресурсы используемые обоими потоками должны быть защищены с помощью разных механизмов синхронизации потоков  
- очередь — должна быть защищена с помощью механизма ``Mutex``, только один поток в моменте может добавлять что-то в неё или доставать из неё. 
- список — должен быть защищён с помощью механизма ``Monitor``, фоновый поток должен ждать доступа, а команда ``list`` должна проверять доступность и в случае, если лист занят - сообщать об этом в консоль
- фоновый поток - должен работать по получению сигнала, используя механизм событий, в данном случае - на основе класса ``AutoResetEvent``

> Для демонстрации корректной работы программы - добавьте Thread.Sleep() на несколько секунд после добавления в очередь и после сортировки списка, а так же после вывода списка в консоль и перед тем как освобождать мьютексы\выходить из области Monitor.

> Корректной будет считаться работа программы, если после 

---